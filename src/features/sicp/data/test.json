[
  {
    "tag": "SUBSECTION",
    "body": "1.2.4  Exponentiation",
    "child": [
      {
        "tag": "TEXT",
        "id": "#p1",
        "child": [
          {
            "tag": "#text",
            "body": " Consider the problem of computing the exponential of a given number. We would like a "
          },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          { "tag": "#text", "body": " that takes as arguments a base " },
          { "tag": "LATEXINLINE", "body": "b" },
          { "tag": "#text", "body": " and a positive integer exponent " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " and computes " },
          { "tag": "LATEXINLINE", "body": "b^n" },
          { "tag": "#text", "body": ". One way to do this is via the recursive definition " },
          {
            "tag": "LATEX",
            "body": "       \\begin{array}{lll}       b^{n} &=& b\\cdot b^{n-1}\\\\       b^{0} &=& 1       \\end{array}       "
          },
          { "tag": "#text", "body": " which translates readily into the " },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 1,
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AUwA8AHCgCgCMAaUEgSlABvXKDGgATgwpEJ9egF4loAAyjxG8QH5U6zRoBcoTqABUjVhx59QAWlT8A3LgC++Zm3YBmXtidA",
            "body": "function expt(b, n) {\n    return n === 0\n           ? 1\n           : b * expt(b, n - 1);\n}\n"
          }
        ]
      },
      {
        "tag": "TEXT",
        "id": "#p2",
        "child": [
          { "tag": "#text", "body": " This is a linear recursive process, which requires " },
          { "tag": "LATEXINLINE", "body": "\\Theta(n)" },
          { "tag": "#text", "body": " steps and " },
          { "tag": "LATEXINLINE", "body": "\\Theta(n)" },
          {
            "tag": "#text",
            "body": " space. Just as with factorial, we can readily formulate an equivalent linear iteration: "
          },
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 2,
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AUwA8AHCgCgCMAaUEgSlABvXKDGgATgwpEJ9ZmwD6VCgwldeJXin4BuXAF9CpSrXmsKy1ep6gyNUtd4sJNACZFKgkeMnTZ9PaOaqAAvOGgAAyivrGgAPygLu6eFDFx4gBcjBZWahp2DiTWoAC0qLycoABUSa4eXvpGuAocAMy82HpAA",
            "body": "function expt(b, n) {\n    return expt_iter(b, n, 1);\n}\nfunction expt_iter(b, counter, product) {\n    return counter === 0\n           ? product\n           : expt_iter(b, counter - 1, b * product);\n}\n"
          },
          { "tag": "#text", "body": " This version requires " },
          { "tag": "LATEXINLINE", "body": "\\Theta(n)" },
          { "tag": "#text", "body": " steps and " },
          { "tag": "LATEXINLINE", "body": "\\Theta(1)" },
          { "tag": "#text", "body": " space. " }
        ]
      },
      {
        "tag": "TEXT",
        "id": "#p3",
        "child": [
          { "tag": "#text", "body": " We can compute exponentials in fewer steps by using " },
          { "tag": "#text", "body": " successive squaring. For instance, rather than computing " },
          { "tag": "LATEXINLINE", "body": "b^8" },
          { "tag": "#text", "body": " as " },
          {
            "tag": "LATEX",
            "body": "       \\begin{array}{l}       b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot b))))))       \\end{array}       "
          },
          { "tag": "#text", "body": " we can compute it using three multiplications: " },
          {
            "tag": "LATEX",
            "body": "       \\begin{array}{lll}       b^{2} &= & b\\cdot b\\\\       b^{4} &= & b^{2}\\cdot b^{2}\\\\       b^{8} &= & b^{4}\\cdot b^{4}       \\end{array}       "
          }
        ]
      },
      {
        "tag": "TEXT",
        "id": "#p4",
        "child": [
          {
            "tag": "#text",
            "body": " This method works fine for exponents that are powers of 2. We can also take advantage of successive squaring in computing exponentials in general if we use the rule "
          },
          {
            "tag": "LATEX",
            "body": "       \\begin{array}{llll}       b^{n} &=& (b^{n/2})^{2}  &\\qquad\\,\\mbox{if}\\ n\\ \\mbox{is even}\\\\       b^{n} &=& b\\cdot b^{n-1} &\\qquad\\mbox{if}\\ n\\ \\mbox{is odd}       \\end{array}       "
          },
          { "tag": "#text", "body": " We can express this method as a " },
          { "child": [{ "child": [{ "tag": "#text", "body": "function:" }] }] },
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 3,
            "program": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4AvvmLlqdUFQYB9TgDdOJbiUEjxEzlJmh6AUlAZQAXk+gADKo2FSSlp6AlYGCiNeAAcKbgAjABpHK1FxSWl6ek93H1SbfIB+VDz88QAuPUMTMwt+EtLQIuY2Lm5Q8MiY+KT6MAx+OoabCriFUHaIzmjYxMdQAFpUfj9NMMnp7gBmJOxloA",
            "prepend": "FDBmFcDsGMBcEsD2kAEBnAjuAhgJwKYAUAHgJQoDewKNKBs4uqxKAVCsQNzAC+IEMBMhTw0AfXwA3fJEKRyVWnXwMmKVAFIUAJhQBeAygAM3HkA",
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AgQwGcKB9AUwA8AHCgCgBGAGlAkAlKADeuUHNAAnDhSIL69ALxbQABlnyD8gPyp9hgwC5QVZpwBuHEvwlnzck8wCORRkv5NWTl4BETFQMAxxcVc3K0FQACoGFnZuPiFRegBaVHEAblwAX3wA1OD+AGZRbHygA",
            "body": "function fast_expt(b, n) {\n    return n === 0\n           ? 1\n           : is_even(n)\n           ? square(fast_expt(b, n / 2))\n           : b * fast_expt(b, n - 1);\n}\n"
          },
          {
            "tag": "#text",
            "body": " where the predicate to test whether an integer is even is defined in terms of the "
          },
          {
            "child": [
              {
                "child": [
                  { "tag": "#text", "body": " \toperator " },
                  { "tag": "JAVASCRIPTINLINE", "body": "%" },
                  {
                    "tag": "#text",
                    "body": ", \twhich computes the remainder after integer division, "
                  }
                ]
              }
            ]
          },
          { "tag": "#text", "body": " by " },
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 4,
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlAZQAXjWgADAG5cAX3xM2nHgHY+WoA",
            "body": "function is_even(n) {\n    return n % 2 === 0;\n}\n"
          }
        ]
      },
      {
        "tag": "TEXT",
        "id": "#p5",
        "child": [
          { "tag": "#text", "body": " The process evolved by " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fast_expt" }] }] },
          { "tag": "#text", "body": " grows logarithmically with " },
          { "tag": "LATEXINLINE", "body": "n" },
          {
            "tag": "#text",
            "body": " in both space and number of steps. To see this, observe that computing "
          },
          { "tag": "LATEXINLINE", "body": "b^{2n}" },
          { "tag": "#text", "body": " using " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fast_expt" }] }] },
          { "tag": "#text", "body": " requires only one more multiplication than computing " },
          { "tag": "LATEXINLINE", "body": "b^n" },
          {
            "tag": "#text",
            "body": ". The size of the exponent we can compute therefore doubles (approximately) with every new multiplication we are allowed. Thus, the number of multiplications required for an exponent of "
          },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " grows about as fast as the logarithm of " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " to the base 2. The process has " },
          { "tag": "LATEXINLINE", "body": "\\Theta(\\log n)" },
          { "tag": "#text", "body": " growth." },
          {
            "tag": "FOOTNOTE_REF",
            "id": "footnote-link-1",
            "body": "1",
            "href": "/interactive-sicp/1.2.4#footnote-1"
          }
        ]
      },
      {
        "tag": "TEXT",
        "id": "#p6",
        "child": [
          { "tag": "#text", "body": " The difference between " },
          { "tag": "LATEXINLINE", "body": "\\Theta(\\log n)" },
          { "tag": "#text", "body": " growth and " },
          { "tag": "LATEXINLINE", "body": "\\Theta(n)" },
          { "tag": "#text", "body": " growth becomes striking as " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " becomes large. For example, " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fast_expt" }] }] },
          { "tag": "#text", "body": " for " },
          { "tag": "LATEXINLINE", "body": "n=1000" },
          { "tag": "#text", "body": " requires only 14 multiplications." },
          {
            "tag": "FOOTNOTE_REF",
            "id": "footnote-link-2",
            "body": "2",
            "href": "/interactive-sicp/1.2.4#footnote-2"
          },
          {
            "tag": "#text",
            "body": " It is also possible to use the idea of successive squaring to devise an iterative algorithm that computes exponentials with a logarithmic number of steps (see exercise "
          },
          {
            "tag": "REF",
            "id": "1.2.4-ex-link-1.16",
            "body": "1.16",
            "href": "/interactive-sicp/1.2.4#ex_1.16"
          },
          {
            "tag": "#text",
            "body": "), although, as is often the case with iterative algorithms, this is not written down so straightforwardly as the recursive algorithm."
          },
          {
            "tag": "FOOTNOTE_REF",
            "id": "footnote-link-3",
            "body": "3",
            "href": "/interactive-sicp/1.2.4#footnote-3"
          }
        ]
      },
      {
        "tag": "EXERCISE",
        "title": "Exercise 1.16",
        "id": "#ex_1.16",
        "child": [
          { "tag": "#text", "body": " Design a " },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          {
            "tag": "#text",
            "body": " that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does "
          },
          {
            "child": [
              {
                "child": [
                  { "tag": "JAVASCRIPTINLINE", "body": "fast_expt" },
                  { "tag": "#text", "body": "." }
                ]
              }
            ]
          },
          { "tag": "#text", "body": " (Hint: Using the observation that " },
          { "tag": "LATEXINLINE", "body": "(b^{n/2})^2 =(b^2)^{n/2}" },
          { "tag": "#text", "body": ", keep, along with the exponent " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " and the base " },
          { "tag": "LATEXINLINE", "body": "b" },
          { "tag": "#text", "body": ", an additional state variable " },
          { "tag": "LATEXINLINE", "body": "a" },
          {
            "tag": "#text",
            "body": ", and define the state transformation in such a way that the product "
          },
          { "tag": "LATEXINLINE", "body": "a b^n" },
          {
            "tag": "#text",
            "body": " is unchanged from state to state. At the beginning of the process "
          },
          { "tag": "LATEXINLINE", "body": "a" },
          { "tag": "#text", "body": " is taken to be 1, and the answer is given by the value of " },
          { "tag": "LATEXINLINE", "body": "a" },
          {
            "tag": "#text",
            "body": " at the end of the process. In general, the technique of defining an "
          },
          { "child": [{ "tag": "#text", "body": "invariant quantity" }] },
          {
            "tag": "#text",
            "body": " that remains unchanged from state to state is a powerful way to think about the design of "
          },
          { "tag": "#text", "body": " iterative algorithms.) " }
        ],
        "solution": [
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 5,
            "program": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlAZQAXjWgADAG5cAX3zFy1OqAIBDRhTYAPAA5WqFVuO5mANKABGH-sLESpGTlVdQ0RfwjQAH5QM3DIsQAuBhYOLl4+eITo0wsrVjsHJxd3L1AAKi8fUDAMTOyk3Msbe2ZHZ1cKqu76AFpUPh19Q0paenNmgvtub1BfLMlpWSb8wrbi7hQPWf4hgzyWim4MDwBmQaA",
            "prepend": "FDBmFcDsGMBcEsD2kAE8DOB9ApgN25ABSQCUKA3sCtSgE7azi2qoCkKATCgLy8oAMAbmABfIA",
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AgQwGcKB9AUwA8AHdqihwBOACkYAaUACNJJAJQBvXKBWghHCkSH16AXn2gADMtWnVAflCMTZ0wC5QVZpwBuHEiPk3bKy01acvPyCohLSoABU0rKgYBhy3j4O-uzcfGwCwmKR0bn0ALSocgDcuAC+hKSUtPQpgXwiMqDySqbqmtoMLKlBGSEiKJJN8qUVhN31FCIYkgDMJUA",
            "body": "function fast_expt_iter(a, b, n){\n    return n === 0\n           ? a\n           : is_even(n)\n           ? fast_expt_iter(a, b * b, n / 2)\n           : fast_expt_iter(a * b, b, n - 1);\n}\nfunction fast_expt(b, n){\n    return fast_expt_iter(1, b, n);\n}\n"
          }
        ]
      },
      {
        "tag": "EXERCISE",
        "title": "Exercise 1.17",
        "id": "#ex_1.17",
        "child": [
          {
            "tag": "#text",
            "body": " The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication "
          },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          {
            "tag": "#text",
            "body": " (in which it is assumed that our language can only add, not multiply) is analogous to the "
          },
          { "tag": "JAVASCRIPTINLINE", "body": "expt" },
          { "child": [{ "child": [{ "tag": "#text", "body": "function:" }] }] },
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 6,
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0agWwFMBnACgEMAaAIwEpQAb1ygxoAE7MKRCfV6gAvMtAAGUeM3iA-Go1bNALlCdQAagZUWHHqAUBaVPwDcuAL74mbdgGZuobBcgA",
            "body": "function times(a,b) {\n    return b === 0\n           ? 0\n           : a + times(a, b - 1);\n}\n"
          },
          { "tag": "#text", "body": " This algorithm takes a number of steps that is linear in " },
          { "tag": "JAVASCRIPTINLINE", "body": "b" },
          { "tag": "#text", "body": ". Now suppose we include, together with addition, " },
          { "child": [{ "child": [{ "tag": "#text", "body": "the functions" }] }] },
          { "tag": "JAVASCRIPTINLINE", "body": "double" },
          { "tag": "#text", "body": ", which doubles an integer, and " },
          { "tag": "JAVASCRIPTINLINE", "body": "halve" },
          {
            "tag": "#text",
            "body": ", which divides an (even) integer by 2. Using these, design a multiplication "
          },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          { "tag": "#text", "body": " analogous to " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fast_expt" }] }] },
          { "tag": "#text", "body": " that uses a logarithmic number of steps. " }
        ],
        "solution": [
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 7,
            "program": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlAZQAXjWgADAG5cAX3zFy1OqAAmNIgCMANq24APAcLESpM+vdABqUPZ37CUkpaegALAENrTgcnETFJaVlfUDAMfwMg43oCcMYKZmoAW1ZGbnCAGlBLJ1A40QT3KtV1FDqXFwB+UHC29tEALm7mlU1QAB8xprURjV6+rtm+9sGmNk4earn2rvMrW24cvIKqYtKK0Aiou2q+Pi2XQfDvUEP8opKyystQAFpUPnShFybxOHwAzJVsACgA",
            "prepend": "FDBmFcDsGMBcEsD2kAE8DOB9ApgN25ABSQCUKA3sCtSgE7azi2qoCkKATCgLy8oAMAbmABfIA",
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AExqICMAbAUwAoAPASlABvXKFGgAThwpFx9HqADUoHgG5cAX3zFy1OqAAWAQzYA3bvyEixk6bOWgwGNZsKlKtegUMBnCgH1qAFsOby5DABpQFgFBUCtRGxl6FlAAXnTUeLFs0AB+UEMsnNEALgK0jIAGUAAfGqiK1NBKouL8luKcsqpvPw4zEi5o1pz8plZOLi9fAKpg0IiDYzMhvjWR7LLDRVBp-yCQsMiUgFpUPmctH325w4BmSOwLoA",
            "body": "function double(x) {\n    return x + x;\n}\n\nfunction halve(x) {\n    return x / 2;\n}\n\nfunction fast_times(a, b) { \n    return b === 1\n           ? a\n           : a === 0 || b === 0\n           ? 0\n           : is_even(b)\n           ? double(fast_times(a, halve(b)))\n           : a + fast_times(a, b - 1);\n}\n"
          }
        ]
      },
      {
        "tag": "EXERCISE",
        "title": "Exercise 1.18",
        "id": "#ex_1.18",
        "child": [
          { "tag": "#text", "body": " Using the results of exercises " },
          {
            "tag": "REF",
            "id": "1.2.4-ex-link-1.16",
            "body": "1.16",
            "href": "/interactive-sicp/1.2.4#ex_1.16"
          },
          { "tag": "#text", "body": " and " },
          {
            "tag": "REF",
            "id": "1.2.4-ex-link-1.17",
            "body": "1.17",
            "href": "/interactive-sicp/1.2.4#ex_1.17"
          },
          { "tag": "#text", "body": ", devise a " },
          { "child": [{ "child": [{ "tag": "#text", "body": "function" }] }] },
          {
            "tag": "#text",
            "body": " that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps."
          },
          {
            "tag": "FOOTNOTE_REF",
            "id": "footnote-link-4",
            "body": "4",
            "href": "/interactive-sicp/1.2.4#footnote-4"
          }
        ],
        "solution": [
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 8,
            "program": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlAZQAXjWgADAG5cAX3zFy1OqAAmNIgCMANq24APAcLESpM+vdABqUPZ37CUkpaegALAENrAgcnETFJaVlfUDAMfwMg43oCcMYKZmoAW1YWKgpWcW4KGgpIgBpQcIbLWJcE91BLVXUUOJd+gH5Qatrrb0a+-rEALkbulU1QAB8lzrUVDUmp0CHN7ZdZpjZOHhatqaGcvIKqYtLyypH6swsbO3C+Boio7ha+c-6syu+SKJWYZQqVRqkXGTUazVAAFpUHx0oEjCFhrcStw4S0hHF2klgTc7uCHtwNA08ai9PhQYxuABmBrYVFAA",
            "prepend": "FDBmFcDsGMBcEsD2kAE8DOB9ApgN25ABSQCUKA3sCtSgE7azi2qoCkKATCgLy8oAMAbmABfIA",
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AExqICMAbAUwAoAPASlABvXKFGgAThwpFx9HqADUoHgG5cAX3zFy1OqAAWAQzYFeA4WIlSZc0GAxrNhUpVr0ChgM4UA+tQC2HJ4+VBQc4lwUNBTGADSghvEs5iJiktKyoCygALx5qKmWRQD8oFExbIoJhUViAFwJufkADKAAPm1ZeTnNNbWgpb39lg1UwRwAbhwkXMl9taUe3n5UgcGh4ZHRcYzM7NyGfPFGJrN8fPNFDUu+AUEhYRHlxlWJCUmgALSofI5aLrp6HdPFw3skhKl0jZQDcVmsHptmvEwb8NPhgVwAMzxbC-IA",
            "body": "function double(x) {\n    return x + x;\n}\n\nfunction half(x) {\n    return x / 2;\n}\n\nfunction fast_times_iter(total, a, b) {\n    return b === 1\n           ? total + a\n           : a === 0 || b===0\n           ? 0\n           : is_even(b)\n           ? fast_times_iter(total, double(a), half(b))\n           : fast_times_iter(total + a, a, b - 1);\n}\n\nfunction times(a, b) {\n  return fast_times_iter(0, a, b);\n}\n"
          }
        ]
      },
      {
        "tag": "EXERCISE",
        "title": "Exercise 1.19",
        "id": "#ex_1.19",
        "child": [
          {
            "tag": "#text",
            "body": " There is a clever algorithm for computing the Fibonacci numbers in a "
          },
          {
            "tag": "#text",
            "body": " logarithmic number of steps. Recall the transformation of the state variables "
          },
          { "tag": "LATEXINLINE", "body": "a" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "b" },
          { "tag": "#text", "body": " in the " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fib_iter" }] }] },
          { "tag": "#text", "body": " process of section " },
          {
            "tag": "REF",
            "id": "1.2.4-ex-link-1.2.2",
            "body": "1.2.2",
            "href": "/interactive-sicp/1.2.2"
          },
          { "tag": "#text", "body": ": " },
          { "tag": "LATEXINLINE", "body": "a\\leftarrow a+b" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "b\\leftarrow a" },
          { "tag": "#text", "body": ". Call this transformation " },
          { "tag": "LATEXINLINE", "body": "T" },
          { "tag": "#text", "body": ", and observe that applying " },
          { "tag": "LATEXINLINE", "body": "T" },
          { "tag": "#text", "body": " over and over again " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": " times, starting with 1 and 0, produces the pair " },
          { "tag": "LATEXINLINE", "body": "\\textrm{Fib}(n+1)" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "\\textrm{Fib}(n)" },
          {
            "tag": "#text",
            "body": ". In other words, the Fibonacci numbers are produced by applying "
          },
          { "tag": "LATEXINLINE", "body": "T^n" },
          { "tag": "#text", "body": ", the " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": "th power of the transformation " },
          { "tag": "LATEXINLINE", "body": "T" },
          { "tag": "#text", "body": ", starting with the pair " },
          { "tag": "LATEXINLINE", "body": "(1,0)" },
          { "tag": "#text", "body": ". Now consider " },
          { "tag": "LATEXINLINE", "body": "T" },
          { "tag": "#text", "body": " to be the special case of " },
          { "tag": "LATEXINLINE", "body": "p=0" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "q=1" },
          { "tag": "#text", "body": " in a family of transformations " },
          { "tag": "LATEXINLINE", "body": "T_{pq}" },
          { "tag": "#text", "body": ", where " },
          { "tag": "LATEXINLINE", "body": "T_{pq}" },
          { "tag": "#text", "body": " transforms the pair " },
          { "tag": "LATEXINLINE", "body": "(a,b)" },
          { "tag": "#text", "body": " according to " },
          { "tag": "LATEXINLINE", "body": "a\\leftarrow bq+aq+ap" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "b\\leftarrow bp+aq" },
          { "tag": "#text", "body": ". Show that if we apply such a transformation " },
          { "tag": "LATEXINLINE", "body": "T_{pq}" },
          {
            "tag": "#text",
            "body": " twice, the effect is the same as using a single transformation "
          },
          { "tag": "LATEXINLINE", "body": "T_{p'q'}" },
          { "tag": "#text", "body": " of the same form, and compute " },
          { "tag": "LATEXINLINE", "body": "p'" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "q'" },
          { "tag": "#text", "body": " in terms of " },
          { "tag": "LATEXINLINE", "body": "p" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "q" },
          {
            "tag": "#text",
            "body": ". This gives us an explicit way to square these transformations, and thus we can compute "
          },
          { "tag": "LATEXINLINE", "body": "T^n" },
          { "tag": "#text", "body": " using successive squaring, as in the " },
          { "child": [{ "child": [{ "tag": "JAVASCRIPTINLINE", "body": "fast_expt" }] }] },
          { "child": [{ "child": [{ "tag": "#text", "body": "function." }] }] },
          { "tag": "#text", "body": " Put this all together to complete the following " },
          { "child": [{ "child": [{ "tag": "#text", "body": "function," }] }] },
          { "tag": "#text", "body": " which runs in a logarithmic number of steps:" },
          {
            "tag": "FOOTNOTE_REF",
            "id": "footnote-link-5",
            "body": "5",
            "href": "/interactive-sicp/1.2.4#footnote-5"
          },
          {
            "tag": "SNIPPET",
            "latex": true,
            "child": [
              {
                "tag": "#text",
                "body": " function fib(n) { return fib_iter(1, 0, 0, 1, n); } function fib_iter(a, b, p, q, count) { return count === 0 ? b : is_even(count) ? fib_iter(a, b, "
              },
              { "tag": "METAPHRASE", "body": "??" },
              { "tag": "#text", "body": ", // compute p' " },
              { "tag": "METAPHRASE", "body": "??" },
              {
                "tag": "#text",
                "body": ", // compute q' count / 2) : fib_iter(b * q + a * q + a * p, b * p + a * q, p, q, count - 1); } \t"
              }
            ]
          }
        ],
        "solution": [
          {
            "tag": "SNIPPET",
            "latex": false,
            "id": 9,
            "program": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlAZQAXjWgADAG5cAX3zFy1OqAJUARrwHCxEqTPpnzzKhVbjuKADSafGn96g-Dr6hKSUtI4WLm4eAIY+5j4ADj4Ajj5kNKQU1iJiktKyoFk5quoa+bbVAPyg5lXVYgBcDCwcXNylJLmNTaB1TjHu3Al9-ROiSeOT-cmgAFSg8wDUoGmL614zs9XKS-NLG2sbR9u7u90UoGAYfDstptGuI+abx6Bx76BrXwfnF0mbwOP0+7wBgLmEMh1QyD0BV1AAFpUHwQgYLNwAKxooA",
            "prepend": "FDBmFcDsGMBcEsD2kAE8DOB9ApgN25ABSQCUKA3sCtSgE7azi2qoCkKATCgLy8oAMAbmABfIA",
            "withoutPrepend": "chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0BYBQuAzAVwDsBjAFwEsB7E0AqgIwAoSBKUAb11D9ABOAUwpEB9RkwD6VCkIEsUAGlAAGFetQqOAblwBffMXLU6DZjLkKAhiqYqADioCOKsjVIVOPfoJFj6d09QAF4wtV5fKNAAflAmSOj+AC5QKgBnKSEANyESFiCSL0Sk2PNpWXkWWxLSuvilWvqkh1AAKlBWgGpQZ3bexubmjH7Wjr6evvHBobrCilAwDHYmqNTJSyqmfonQax3QHv2Op1XZvm2Tw72dmfPo0-uk1zPz+dAAWlR2PUNCZhYAFYfkA",
            "body": "function fib(n) {\n    return fib_iter(1, 0, 0, 1, n);\n}\n\nfunction fib_iter(a, b, p, q, count) {\n    return count === 0\n           ? b\n           : is_even(count)\n           ? fib_iter(a,\n                      b,\n                      p * p + q * q,\n                      2 * p * q + q * q,\n                      count / 2)\n           : fib_iter(b * q + a * q + a * p,\n                      b * p + a * q,\n                      p,\n                      q,\n                      count - 1);\n}\n"
          }
        ]
      },
      {
        "tag": "DISPLAYFOOTNOTE",
        "id": "#footnote-1",
        "count": 1,
        "child": [
          {
            "tag": "#text",
            "body": "More precisely, the number of multiplications required is equal to 1 less than the log base 2 of "
          },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": ", plus the number of ones in the binary representation of " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": ". This total is always less than twice the log base 2 of " },
          { "tag": "LATEXINLINE", "body": "n" },
          { "tag": "#text", "body": ". The arbitrary constants " },
          { "tag": "LATEXINLINE", "body": "k_1" },
          { "tag": "#text", "body": " and " },
          { "tag": "LATEXINLINE", "body": "k_2" },
          {
            "tag": "#text",
            "body": " in the definition of order notation imply that, for a logarithmic process, the base to which logarithms are taken does not matter, so all such processes are described as "
          },
          { "tag": "LATEXINLINE", "body": "\\Theta(\\log n)" },
          { "tag": "#text", "body": "." }
        ]
      },
      {
        "tag": "DISPLAYFOOTNOTE",
        "id": "#footnote-2",
        "count": 2,
        "child": [
          {
            "tag": "#text",
            "body": "You may wonder why anyone would care about raising numbers to the 1000th power. See section "
          },
          {
            "tag": "REF",
            "id": "1.2.4-ex-link-1.2.6",
            "body": "1.2.6",
            "href": "/interactive-sicp/1.2.6"
          },
          { "tag": "#text", "body": "." }
        ]
      },
      {
        "tag": "DISPLAYFOOTNOTE",
        "id": "#footnote-3",
        "count": 3,
        "child": [
          { "tag": "#text", "body": "This iterative algorithm is ancient. It appears in the " },
          { "child": [{ "tag": "#text", "body": "Chandah-sutra" }] },
          { "tag": "#text", "body": " by " },
          { "tag": "#text", "body": "Áchárya, written before 200 BCE. See " },
          { "child": [{ "tag": "#text", "body": "Knuth 1997b" }] },
          {
            "tag": "#text",
            "body": ", section 4.6.3, for a full discussion and analysis of this and other methods of exponentiation."
          }
        ]
      },
      {
        "tag": "DISPLAYFOOTNOTE",
        "id": "#footnote-4",
        "count": 4,
        "child": [
          { "tag": "#text", "body": "This algorithm, which is sometimes known as the " },
          {
            "tag": "#text",
            "body": "\"Russian peasant method\" of multiplication, is ancient. Examples of its use are found in the "
          },
          {
            "tag": "#text",
            "body": " Rhind Papyrus, one of the two oldest mathematical documents in existence, written about 1700 BCE (and copied from an even older document) by an Egyptian scribe named "
          },
          { "tag": "#text", "body": " A'h-mose." }
        ]
      },
      {
        "tag": "DISPLAYFOOTNOTE",
        "id": "#footnote-5",
        "count": 5,
        "child": [
          { "tag": "#text", "body": "This exercise was suggested to us by " },
          { "tag": "#text", "body": " Joe Stoy, based on an example in " },
          { "child": [{ "tag": "#text", "body": "Kaldewaij 1990" }] },
          { "tag": "#text", "body": "." }
        ]
      }
    ]
  }
]
