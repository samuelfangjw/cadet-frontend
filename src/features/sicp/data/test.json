[{"tag":"SUBSECTION","body":"1.1.3  \n    Evaluating\n    \n      \n      Operator Combinations\n    \n  ","child":[{"tag":"TEXT","child":[{"tag":"#text","body":" One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating "},{"child":[{"child":[{"tag":"#text","body":" \toperator "}]}]},{"tag":"#text","body":" combinations, the interpreter is itself following a procedure. "},{"tag":"#text","body":" To evaluate "},{"child":[{"child":[{"tag":"#text","body":" \t an operator combination, \t"}]}]},{"tag":"#text","body":" do the following: "},{"tag":"OL","body":"</OL>","child":[{"child":[{"tag":"#text","body":"Evaluate the \t"},{"child":[{"child":[{"tag":"#text","body":" \t operand expressions \t "}]}]},{"tag":"#text","body":" \tof the combination."}]},{"child":[{"child":[{"child":[{"tag":"#text","body":" \t Apply the function that is denoted by the operator to the arguments that are the values of the operands. \t "}]}]}]}]},{"tag":"#text","body":" Even this simple rule illustrates some important points about processes in general. First, observe that the first step dictates that in order to accomplish the evaluation process for a combination we must first perform the evaluation process on each operand of the combination. Thus, the evaluation rule is "},{"child":[{"tag":"#text","body":"recursive"}]},{"tag":"#text","body":" in nature; that is, it includes, as one of its steps, the need to invoke the rule itself."},{"child":[]}]},{"tag":"TEXT","child":[{"tag":"#text","body":" Notice how succinctly the idea of recursion can be used to express "},{"tag":"#text","body":" what, in the case of a deeply nested combination, would otherwise be viewed as a rather complicated process. For example, evaluating "},{"tag":"SNIPPET","url":"http://source-academy.github.io/playground#chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToMwChsAoAmUAalABZQAqUANgEorQ9MTUC6BuIA","body":"(2 + 4 * 6) * (3 + 12);\n"},{"tag":"#text","body":" requires that the evaluation rule be applied to four different combinations. We can obtain a picture of this process by representing the combination in the form of a "},{"tag":"#text","body":" tree, as shown in "},{"child":[{"child":[{"tag":"#text","body":" \tfigure"},{"tag":"SPACE","body":" "},{"tag":"REF","body":"<REF NAME=\"fig:tree-comb\"><a class=\"superscript\" id=\"1.1.3-fig-link-1.1\" href=\"./1.1.3.html#fig_1.1\">1.1</a></REF>"},{"tag":"#text","body":". "}]}]},{"tag":"#text","body":" Each combination is represented by a "},{"tag":"#text","body":" node with "},{"tag":"#text","body":" branches corresponding to the operator and the operands of the combination stemming from it. The "},{"tag":"#text","body":" terminal nodes (that is, nodes with no branches stemming from them) represent either operators or numbers. Viewing evaluation in terms of the tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels. In general, we shall see that recursion is a very powerful technique for dealing with hierarchical, treelike objects. In fact, the "},{"child":[{"tag":"#text","body":"percolate values upward"}]},{"tag":"#text","body":" form of the evaluation rule is an example of a general kind of process known as "},{"child":[{"tag":"#text","body":"tree accumulation"}]},{"tag":"#text","body":". "},{"child":[{"child":[{"child":[{"tag":"FIGURE","images":[{"class":"scale_factor_","src":"img_javascript/ch1-Z-G-1.svg"}]}],"tag":"FIGURE","images":[{"class":"scale_factor_","src":"img_javascript/ch1-Z-G-1.svg","captionHref":"1.1.3.html#fig_1.1","captionName":"Figure 1.1 Tree representation, showing the value of each subexpression. "}]}]}]}]},{"tag":"TEXT","child":[{"tag":"#text","body":" Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not combinations, but primitive expressions such as "},{"child":[{"child":[{"tag":"#text","body":" \tnumerals or names. "}]}]},{"tag":"#text","body":" We take care of the primitive cases "},{"tag":"#text","body":" by stipulating that "},{"child":[{"child":[{"tag":"#text","body":" the values of numerals are the numbers that they name, \t"},{"child":[{"child":[{"tag":"#text","body":"and"}]}]}]},{"child":[]},{"child":[{"tag":"#text","body":" the values of \t"},{"child":[]},{"tag":"#text","body":" \tnames are the objects associated with those names in the environment. "}]}]}]},{"tag":"TEXT","child":[{"child":[]},{"tag":"#text","body":" The key point to notice is the role of the "},{"tag":"#text","body":" environment in determining the meaning of the "},{"child":[{"child":[{"tag":"#text","body":" \tnames "}]}]},{"tag":"#text","body":" in expressions. In an interactive language such as "},{"child":[{"child":[{"tag":"#text","body":" \tJavaScript, "}]}]},{"tag":"#text","body":" it is meaningless to speak of the value of an expression such as "},{"child":[{"child":[{"tag":"JAVASCRIPTINLINE","body":"x + 1"}]}]},{"tag":"#text","body":" without specifying any information about the environment that would provide a meaning for the "},{"child":[{"child":[{"tag":"#text","body":" \tname "},{"tag":"#text","body":". "}]}]},{"tag":"#text","body":" As we shall see in chapter 3, the general notion of the environment as providing a context in which evaluation takes place will play an important role in our understanding of program execution. "},{"child":[{"child":[]}]}]},{"tag":"TEXT","child":[{"tag":"#text","body":" Notice that the evaluation rule given above does not handle "},{"child":[{"child":[{"tag":"#text","body":" \tdeclarations. "}]}]},{"tag":"#text","body":" For instance, evaluating "},{"child":[{"child":[{"tag":"JAVASCRIPTINLINE","body":"const x = 3;"}]}]},{"tag":"#text","body":" does not apply "},{"child":[{"child":[{"tag":"#text","body":" \tan equality operator "},{"tag":"JAVASCRIPTINLINE","body":"="}]}]},{"tag":"#text","body":" to two arguments, one of which is the value of the "},{"child":[{"child":[{"tag":"#text","body":" \tname "}]}]},{"tag":"#text","body":" and the other of which is 3, since the purpose of the "},{"child":[{"child":[{"tag":"#text","body":" \tdeclaration "}]}]},{"tag":"#text","body":" is precisely to associate "},{"tag":"#text","body":" with a value. (That is, "},{"child":[{"child":[{"tag":"JAVASCRIPTINLINE","body":"const x = 3;"}]}]},{"tag":"#text","body":" is not a combination.) "}]},{"tag":"TEXT","child":[{"child":[{"child":[{"tag":"TEXT","child":[{"tag":"#text","body":" The letters in "},{"tag":"JAVASCRIPTINLINE","body":"const"},{"tag":"#text","body":" are rendered in bold to indicate that it is a \t "},{"child":[{"tag":"#text","body":"keyword"}]},{"tag":"#text","body":" in JavaScript. Keywords carry a \t particular meaning, and thus cannot be used as names. A keyword or a \t combination of keywords in a statement instructs the JavaScript \t interpreter to treat the statement in a special way. Each such \t "},{"child":[{"tag":"#text","body":"syntactic form"}]},{"tag":"#text","body":" has its own evaluation rule. The \t various kinds of statements and expressions (each with its associated \t evaluation rule) constitute the "},{"tag":"#text","body":" syntax of the programming language. "}]}]}]}]}]}]