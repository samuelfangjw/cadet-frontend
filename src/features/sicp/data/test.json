[{"tag":"REFERENCES","body":"References","child":[{"tag":"REFERENCE","child":[{"tag":"#text","body":" Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The Supercomputer Toolkit: A general framework for special-purpose computing. "},{"child":[{"tag":"#text","body":"International Journal of High-Speed Electronics"}]},{"tag":"#text","body":" 3(3):337–361."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":" Allen, John. 1978. "},{"child":[{"tag":"#text","body":"Anatomy of Lisp."}]},{"tag":"#text","body":" New York: McGraw-Hill. "}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Appel, Andrew W. 1987. Garbage collection can be faster than stack allocation. "},{"child":[{"tag":"#text","body":"Information Processing Letters"}]},{"tag":"#text","body":" 25(4):275–279."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Backus, John. 1978. Can programming be liberated from the von Neumann style? "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 21(8):613–641."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Baker, Henry G., Jr. 1978. List processing in real time on a serial computer. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 21(4):280–293."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982. The Scheme-81 architecture—System and chip. In "},{"child":[{"tag":"#text","body":"Proceedings of the MIT Conference on Advanced Research in VLSI,"}]},{"tag":"#text","body":" edited by Paul Penfield, Jr. Dedham, MA: Artech House."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Borning, Alan. 1977. ThingLab—An object-oriented system for building simulations using constraints. In "},{"child":[{"tag":"#text","body":"Proceedings of the 5th International Joint Conference on Artificial Intelligence."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Borodin, Alan, and Ian Munro. 1975. "},{"child":[{"tag":"#text","body":"The Computational Complexity of Algebraic and Numeric Problems."}]},{"tag":"#text","body":" New York: American Elsevier."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Chaitin, Gregory J. 1975. Randomness and mathematical proof. "},{"child":[{"tag":"#text","body":"Scientific American"}]},{"tag":"#text","body":" 232(5):47–52."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Church, Alonzo. 1941. "},{"child":[{"tag":"#text","body":"The Calculi of Lambda-Conversion."}]},{"tag":"#text","body":" Princeton, N.J.: Princeton University Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Clark, Keith L. 1978. Negation as failure. In "},{"child":[{"tag":"#text","body":"Logic and Data Bases."}]},{"tag":"#text","body":" New York: Plenum Press, pp. 293–322."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Clinger, William. 1982. Nondeterministic call by need is neither lazy nor by name. In "},{"child":[{"tag":"#text","body":"Proceedings of the ACM Symposium on Lisp and Functional Programming,"}]},{"tag":"#text","body":" pp. 226–234."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un système de communication homme-machine en français. Technical report, Groupe d'Intelligence Artificielle, Université d'Aix-Marseille II, Luminy."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Cormen, Thomas, Charles Leiserson, Ronald Rivest, and Clifford Stein. 2022. "},{"child":[{"tag":"#text","body":"Introduction to Algorithms."}]},{"tag":"#text","body":" 4th edition. Cambridge, MA: MIT Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Crockford, Douglas. 2008. "},{"child":[{"tag":"#text","body":"JavaScript: The Good Parts."}]},{"tag":"#text","body":" Sebastopol, CA: O'Reilly Media."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Darlington, John, Peter Henderson, and David Turner. 1982. "},{"child":[{"tag":"#text","body":"Functional Programming and Its Applications."}]},{"tag":"#text","body":" New York: Cambridge University Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Dijkstra, Edsger W. 1968a. The structure of the \"THE\" multiprogramming system. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 11(5):341–346."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In "},{"child":[{"tag":"#text","body":"Programming Languages"}]},{"tag":"#text","body":", edited by F. Genuys. New York: Academic Press, pp. 43–112."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Dinesman, Howard P. 1968. "},{"child":[{"tag":"#text","body":"Superior Mathematical Puzzles"}]},{"tag":"#text","body":". New York: Simon and Schuster."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"de Kleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977. AMORD: Explicit control of reasoning. In "},{"child":[{"tag":"#text","body":"Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages,"}]},{"tag":"#text","body":" pp. 116–125."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Doyle, Jon. 1979. A truth maintenance system. "},{"child":[{"tag":"#text","body":"Artificial Intelligence"}]},{"tag":"#text","body":" 12:231–272."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"ECMA. 1997. ECMAScript: A general purpose, cross-platform programming language, edited by Guy L. Steele Jr. "},{"child":[{"tag":"#text","body":"Ecma International."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"ECMA. 2015. ECMAScript: A general purpose, cross-platform programming language. 6th edition, edited by Allen Wirfs-Brock. "},{"child":[{"tag":"#text","body":"Ecma International."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"ECMA. 2020. ECMAScript: A general purpose, cross-platform programming language. 11th edition, edited by Jordan Harband. "},{"child":[{"tag":"#text","body":"Ecma International."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Edwards, A. W. F. 2019. "},{"child":[{"tag":"#text","body":"Pascal's Arithmetical Triangle"}]},{"tag":"#text","body":". Mineola, New York: Dover Publications."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Feeley, Marc. 1986. Deux approches à l'implantation du language Scheme. Masters thesis, Université de Montréal."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation. "},{"child":[{"tag":"#text","body":"Journal of Computer Languages"}]},{"tag":"#text","body":" 12(1):47–66."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction, survey, and evaluation. In "},{"child":[{"tag":"#text","body":"Future Generation Computer Systems,"}]},{"tag":"#text","body":" vol. 9, pp. 105–117."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Feller, William. 1957. "},{"child":[{"tag":"#text","body":"An Introduction to Probability Theory and Its Applications,"}]},{"tag":"#text","body":" volume 1. New York: John Wiley \\& Sons."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtual memory computer systems. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 12(11):611–612."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Floyd, Robert. 1967. Nondeterministic algorithms. "},{"child":[{"tag":"#text","body":"JACM,"}]},{"tag":"#text","body":" 14(4):636–644."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Forbus, Kenneth D., and Johan de Kleer. 1993. "},{"child":[{"tag":"#text","body":"Building Problem Solvers."}]},{"tag":"#text","body":" Cambridge, MA: MIT Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Friedman, Daniel P., and David S. Wise. 1976. CONS should not evaluate its arguments. In "},{"child":[{"tag":"#text","body":"Automata, Languages, and Programming: Third International Colloquium,"}]},{"tag":"#text","body":" edited by S. Michaelson and R. Milner, pp. 257–284."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992. "},{"child":[{"tag":"#text","body":"Essentials of Programming Languages."}]},{"tag":"#text","body":" Cambridge, MA: MIT Press/McGraw-Hill."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Gabriel, Richard P. 1988. The Why of "},{"child":[{"tag":"#text","body":"Y"}]},{"tag":"#text","body":". "},{"child":[{"tag":"#text","body":"Lisp Pointers"}]},{"tag":"#text","body":" 2(2):15–25."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Goldberg, Adele, and David Robson. 1983. "},{"child":[{"tag":"#text","body":"Smalltalk-80: The Language and Its Implementation."}]},{"tag":"#text","body":" Reading, MA: Addison-Wesley."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979. "},{"child":[{"tag":"#text","body":"Edinburgh LCF."}]},{"tag":"#text","body":" Lecture Notes in Computer Science, volume 78. New York: Springer-Verlag."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Gray, Jim, and Andreas Reuter. 1993. "},{"child":[{"tag":"#text","body":"Transaction Processing: Concepts and Models."}]},{"tag":"#text","body":" San Mateo, CA: Morgan-Kaufman."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Green, Cordell. 1969. Application of theorem proving to problem solving. In "},{"child":[{"tag":"#text","body":"Proceedings of the International Joint Conference on Artificial Intelligence,"}]},{"tag":"#text","body":" pp. 219–240."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Green, Cordell, and Bertram Raphael. 1968. The use of theorem-proving techniques in question-answering systems. In "},{"child":[{"tag":"#text","body":"Proceedings of the ACM National Conference,"}]},{"tag":"#text","body":" pp. 169–181."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Guttag, John V. 1977. Abstract data types and the development of data structures. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 20(6):397–404."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hamming, Richard W. 1980. "},{"child":[{"tag":"#text","body":"Coding and Information Theory."}]},{"tag":"#text","body":" Englewood Cliffs, N.J.: Prentice-Hall."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hanson, Christopher P. 1990. Efficient stack allocation for tail-recursive languages. In "},{"child":[{"tag":"#text","body":"Proceedings of ACM Conference on Lisp and Functional Programming,"}]},{"tag":"#text","body":" pp. 106–118."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hanson, Christopher P. 1991. A syntactic closures macro facility. "},{"child":[{"tag":"#text","body":"Lisp Pointers,"}]},{"tag":"#text","body":" 4(3)."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hardy, Godfrey H. 1921. Srinivasa Ramanujan. "},{"child":[{"tag":"#text","body":"Proceedings of the London Mathematical Society"}]},{"tag":"#text","body":" XIX(2)."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hardy, Godfrey H., and E. M. Wright. 1960. "},{"child":[{"tag":"#text","body":"An Introduction to the Theory of Numbers."}]},{"tag":"#text","body":" 4th edition. New York: Oxford University Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. "},{"child":[{"tag":"#text","body":"IBM Systems Journal"}]},{"tag":"#text","body":" 7(2):74–84."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Henderson, Peter. 1980. "},{"child":[{"tag":"#text","body":"Functional Programming: Application and Implementation."}]},{"tag":"#text","body":" Englewood Cliffs, N.J.: Prentice-Hall."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Henderson. Peter. 1982. Functional Geometry. In "},{"child":[{"tag":"#text","body":"Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming,"}]},{"tag":"#text","body":" pp. 179–187."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hewitt, Carl E. 1969. PLANNER: A language for proving theorems in robots. In "},{"child":[{"tag":"#text","body":"Proceedings of the International Joint Conference on Artificial Intelligence,"}]},{"tag":"#text","body":" pp. 295–301."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hewitt, Carl E. 1977. Viewing control structures as patterns of passing messages. "},{"child":[{"tag":"#text","body":"Journal of Artificial Intelligence"}]},{"tag":"#text","body":" 8(3):323–364."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hoare, C. A. R. 1972. Proof of correctness of data representations. "},{"child":[{"tag":"#text","body":"Acta Informatica"}]},{"tag":"#text","body":" 1(1)."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hodges, Andrew. 1983. "},{"child":[{"tag":"#text","body":"Alan Turing: The Enigma."}]},{"tag":"#text","body":" New York: Simon and Schuster."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hofstadter, Douglas R. 1979. "},{"child":[{"tag":"#text","body":"Gödel, Escher, Bach: An Eternal Golden Braid."}]},{"tag":"#text","body":" New York: Basic Books."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Hughes, R. J. M. 1990. Why functional programming matters. In "},{"child":[{"tag":"#text","body":"Research Topics in Functional Programming"}]},{"tag":"#text","body":", edited by David Turner. Reading, MA: Addison-Wesley, pp. 17–42."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"IEEE Std 1178-1990. 1990. "},{"child":[{"tag":"#text","body":"IEEE Standard for the Scheme Programming Language."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way of compiling procedure statements, with some comments on procedure declarations. Unpublished manuscript. (Also, private communication from Wallace Feurzeig.)"}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Jaffar, Joxan, and Peter J. Stuckey. 1986. Semantics of infinite tree logic programming. "},{"child":[{"tag":"#text","body":"Theoretical Computer Science"}]},{"tag":"#text","body":" 46:141–158."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Kaldewaij, Anne. 1990. "},{"child":[{"tag":"#text","body":"Programming: The Derivation of Algorithms."}]},{"tag":"#text","body":" New York: Prentice-Hall."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Knuth, Donald E. 1997a. "},{"child":[{"tag":"#text","body":"Fundamental Algorithms."}]},{"tag":"#text","body":" Volume 1 of "},{"child":[{"tag":"#text","body":"The Art of Computer Programming."}]},{"tag":"#text","body":" 3rd edition. Reading, MA: Addison-Wesley."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Knuth, Donald E. 1997b. "},{"child":[{"tag":"#text","body":"Seminumerical Algorithms."}]},{"tag":"#text","body":" Volume 2 of "},{"child":[{"tag":"#text","body":"The Art of Computer Programming."}]},{"tag":"#text","body":" 3rd edition. Reading, MA: Addison-Wesley."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Konopasek, Milos, and Sundaresan Jayaraman. 1984. "},{"child":[{"tag":"#text","body":"The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education."}]},{"tag":"#text","body":" Berkeley, CA: Osborne/McGraw-Hill."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Kowalski, Robert. 1973. Predicate logic as a programming language. Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Kowalski, Robert. 1979. "},{"child":[{"tag":"#text","body":"Logic for Problem Solving."}]},{"tag":"#text","body":" New York: North-Holland."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Lamport, Leslie. 1978. Time, clocks, and the ordering of events in a distributed system. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 21(7):558–565."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981. Report on the programming language Euclid. Technical report, Computer Systems Research Group, University of Toronto."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambda notation: Part I. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 8(2):89–101."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based on the lifetimes of objects. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 26(6):419–429."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques for data abstractions. "},{"child":[{"tag":"#text","body":"IEEE Transactions on Software Engineering"}]},{"tag":"#text","body":" 1(1):7–19."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo 473, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"McCarthy, John. 1967. A basis for a mathematical theory of computation. In "},{"child":[{"tag":"#text","body":"Computer Programing and Formal Systems"}]},{"tag":"#text","body":", edited by P. Braffort and D. Hirschberg. North-Holland."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality. "},{"child":[{"tag":"#text","body":"Journal of Computer and System Sciences"}]},{"tag":"#text","body":" 13(3):300–317."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Moon, David. 1978. MacLisp reference manual, Version 0. Technical report, MIT Laboratory for Computer Science."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with an applicative string processing language. In "},{"child":[{"tag":"#text","body":"Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages."}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Phillips, Hubert. 1934. "},{"child":[{"tag":"#text","body":"The Sphinx Problem Book"}]},{"tag":"#text","body":". London: Faber and Faber."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Rabin, Michael O. 1980. Probabilistic algorithm for testing primality. "},{"child":[{"tag":"#text","body":"Journal of Number Theory"}]},{"tag":"#text","body":" 12:128–138."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Raymond, Eric. 1996. "},{"child":[{"tag":"#text","body":"The New Hacker's Dictionary."}]},{"tag":"#text","body":" 3rd edition. Cambridge, MA: MIT Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Raynal, Michel. 1986. "},{"child":[{"tag":"#text","body":"Algorithms for Mutual Exclusion."}]},{"tag":"#text","body":" Cambridge, MA: MIT Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or, lambda: The ultimate software tool. In "},{"child":[{"tag":"#text","body":"Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming,"}]},{"tag":"#text","body":" pp. 114–122."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Rivest, Ronald, Adi Shamir, and Leonard Adleman. 1977. A method for obtaining digital signatures and public-key cryptosystems. Technical memo LCS/TM82, MIT Laboratory for Computer Science."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Robinson, J. A. 1965. A machine-oriented logic based on the resolution principle. "},{"child":[{"tag":"#text","body":"Journal of the ACM"}]},{"tag":"#text","body":" 12(1):23."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Robinson, J. A. 1983. Logic programming—Past, present, and future. "},{"child":[{"tag":"#text","body":"New Generation Computing"}]},{"tag":"#text","body":" 1:107–124."}]},{"child":[{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sagade, Y. 2015. "},{"tag":"LINK","body":"http://www.ysagade.nl/2015/04/12/sicp-change-growth/","child":[{"tag":"#text","body":"SICP exercise 1.14"}]}]}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath. "},{"child":[{"tag":"#text","body":"Communications of the ACM"}]},{"tag":"#text","body":" 32(6):678–688."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Steele, Guy Lewis, Jr. 1977. Debunking the \"expensive procedure call\" myth. In "},{"child":[{"tag":"#text","body":"Proceedings of the National Conference of the ACM,"}]},{"tag":"#text","body":" pp. 153–162."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo 349, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. "},{"child":[{"tag":"#text","body":"The Hacker's Dictionary."}]},{"tag":"#text","body":" New York: Harper \\& Row."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Stoy, Joseph E. 1977. "},{"child":[{"tag":"#text","body":"Denotational Semantics."}]},{"tag":"#text","body":" Cambridge, MA: MIT Press."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques in computer-aided circuit analysis. "},{"child":[{"tag":"#text","body":"IEEE Transactions on Circuits and Systems"}]},{"tag":"#text","body":" CAS-22(11):857–865."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints—A language for expressing almost-hierarchical descriptions. "},{"child":[{"tag":"#text","body":"AI Journal"}]},{"tag":"#text","body":" 14:1–39."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solar system. "},{"child":[{"tag":"#text","body":"Science"}]},{"tag":"#text","body":" 257:256–262."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplanner reference manual. Memo 203A, MIT Artificial Intelligence Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphical communication system. Technical report 296, MIT Lincoln Laboratory."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data type specification: Parameterization and the power of specification techniques. In "},{"child":[{"tag":"#text","body":"Conference Record of the Tenth Annual ACM Symposium on Theory of Computing"}]},{"tag":"#text","body":", pp. 119–132."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Turner, David. 1981. The future of applicative languages. In "},{"child":[{"tag":"#text","body":"Proceedings of the 3rd European Conference on Informatics,"}]},{"tag":"#text","body":" Lecture Notes in Computer Science, volume 123. New York: Springer-Verlag, pp. 334–348."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Wand, Mitchell. 1980. Continuation-based program transformation strategies. "},{"child":[{"tag":"#text","body":"Journal of the ACM"}]},{"tag":"#text","body":" 27(1):164–180."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Waters, Richard C. 1979. A method for analyzing loop programs. "},{"child":[{"tag":"#text","body":"IEEE Transactions on Software Engineering"}]},{"tag":"#text","body":" 5(3):237–247."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Winston, Patrick. 1992. "},{"child":[{"tag":"#text","body":"Artificial Intelligence"}]},{"tag":"#text","body":". 3rd edition. Reading, MA: Addison-Wesley."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic Lisp with dependency-directed backtracking. "},{"child":[{"tag":"#text","body":"AAAI-87"}]},{"tag":"#text","body":", pp. 59–64."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials. Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT."}]},{"tag":"REFERENCE","child":[{"tag":"#text","body":"Zippel, Richard. 1993. "},{"child":[{"tag":"#text","body":"Effective Polynomial Computation."}]},{"tag":"#text","body":" Boston, MA: Kluwer Academic Publishers."}]}]}]